<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Lazy API of Polars"><meta name="keywords" content="rust, rustlang, rust-lang, polars_lazy"><title>polars_lazy - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../polars_lazy/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.png" alt="logo"></div>
        </a><h2 class="location">Crate polars_lazy</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.19.1</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all polars_lazy's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><div id="sidebar-vars" data-name="polars_lazy" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../polars_lazy/index.html"><img class="rust-logo" src="../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">polars_lazy</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/polars_lazy/lib.rs.html#1-212" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Lazy API of Polars</p>
<p><em>Credits to the work of Andy Grove and Ballista/ DataFusion / Apache Arrow, which served as
inspiration for the lazy API.</em></p>
<p>The lazy api of Polars supports a subset of the eager api. Apart from the distributed compute,
it is very similar to <a href="https://spark.apache.org/">Apache Spark</a>. You write queries in a
domain specific language. These queries translate to a logical plan, which represent your query steps.
Before execution this logical plan is optimized and may change the order of operations if this will increase performance.
Or implicit type casts may be added such that execution of the query won’t lead to a type error (if it can be resolved).</p>
<h2 id="lazy-dsl" class="section-header"><a href="#lazy-dsl">Lazy DSL</a></h2>
<p>The lazy API of polars can be used as long we operation on one or multiple DataFrame(s) and
Series of the same length as the DataFrame. To get started we call the <a href="frame/trait.IntoLazy.html#tymethod.lazy">lazy</a>
method. This returns a <a href="frame/struct.LazyFrame.html">LazyFrame</a> exposing the lazy API.</p>
<p>Lazy operations don’t execute until we call <a href="frame/struct.LazyFrame.html#method.collect">collect</a>.
This allows polars to optimize/reorder the query which may lead to faster queries or less type errors.</p>
<p>The DSL is mostly defined by <a href="frame/struct.LazyFrame.html">LazyFrame</a> for operations on DataFrames and
the <a href="dsl/enum.Expr.html">Expr</a> and functions in the <a href="dsl/index.html">dsl modules</a> that operate
on expressions.</p>
<h3 id="examples" class="section-header"><a href="#examples">Examples</a></h3><h5 id="adding-a-new-column-to-a-lazy-dataframe" class="section-header"><a href="#adding-a-new-column-to-a-lazy-dataframe">Adding a new column to a lazy DataFrame</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">polars_core</span>;
 <span class="kw">use</span> <span class="ident">polars_core::prelude</span>::<span class="kw-2">*</span>;
 <span class="kw">use</span> <span class="ident">polars_lazy::prelude</span>::<span class="kw-2">*</span>;

 <span class="kw">let</span> <span class="ident">df</span> <span class="op">=</span> <span class="macro">df!</span> {
     <span class="string">&quot;column_a&quot;</span> =&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot;</span> =&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.<span class="ident">unwrap</span>();

 <span class="kw">let</span> <span class="ident">new</span> <span class="op">=</span> <span class="ident">df</span>.<span class="ident">lazy</span>()
     <span class="comment">// Note the reverse here!!</span>
     .<span class="ident">reverse</span>()
     .<span class="ident">with_column</span>(
         <span class="comment">// always rename a new column</span>
         (<span class="ident">col</span>(<span class="string">&quot;column_a&quot;</span>) <span class="op">*</span> <span class="ident">lit</span>(<span class="number">10</span>)).<span class="ident">alias</span>(<span class="string">&quot;new_column&quot;</span>)
     )
     .<span class="ident">collect</span>()
     .<span class="ident">unwrap</span>();

 <span class="macro">assert!</span>(<span class="ident">new</span>.<span class="ident">column</span>(<span class="string">&quot;new_column&quot;</span>)
     .<span class="ident">unwrap</span>()
     .<span class="ident">series_equal</span>(
         <span class="kw-2">&amp;</span><span class="ident">Series::new</span>(<span class="string">&quot;new_column&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>])
     )
 );</code></pre></div>
<h5 id="modifying-a-column-based-on-some-predicate" class="section-header"><a href="#modifying-a-column-based-on-some-predicate">Modifying a column based on some predicate</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">polars_core</span>;
 <span class="kw">use</span> <span class="ident">polars_core::prelude</span>::<span class="kw-2">*</span>;
 <span class="kw">use</span> <span class="ident">polars_lazy::prelude</span>::<span class="kw-2">*</span>;

 <span class="kw">let</span> <span class="ident">df</span> <span class="op">=</span> <span class="macro">df!</span> {
     <span class="string">&quot;column_a&quot;</span> =&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot;</span> =&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.<span class="ident">unwrap</span>();

 <span class="kw">let</span> <span class="ident">new</span> <span class="op">=</span> <span class="ident">df</span>.<span class="ident">lazy</span>()
     .<span class="ident">with_column</span>(
         <span class="comment">// value = 100 if x &lt; 3 else x</span>
         <span class="ident">when</span>(
             <span class="ident">col</span>(<span class="string">&quot;column_a&quot;</span>).<span class="ident">lt</span>(<span class="ident">lit</span>(<span class="number">3</span>))
         ).<span class="ident">then</span>(
             <span class="ident">lit</span>(<span class="number">100</span>)
         ).<span class="ident">otherwise</span>(
             <span class="ident">col</span>(<span class="string">&quot;column_a&quot;</span>)
         ).<span class="ident">alias</span>(<span class="string">&quot;new_column&quot;</span>)
     )
     .<span class="ident">collect</span>()
     .<span class="ident">unwrap</span>();

 <span class="macro">assert!</span>(<span class="ident">new</span>.<span class="ident">column</span>(<span class="string">&quot;new_column&quot;</span>)
     .<span class="ident">unwrap</span>()
     .<span class="ident">series_equal</span>(
         <span class="kw-2">&amp;</span><span class="ident">Series::new</span>(<span class="string">&quot;new_column&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">100</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])
     )
 );</code></pre></div>
<h5 id="groupby--aggregations" class="section-header"><a href="#groupby--aggregations">Groupby + Aggregations</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use</span> <span class="ident">polars_core::prelude</span>::<span class="kw-2">*</span>;
 <span class="kw">use</span> <span class="ident">polars_core::df</span>;
 <span class="kw">use</span> <span class="ident">polars_lazy::prelude</span>::<span class="kw-2">*</span>;
 <span class="kw">use</span> <span class="ident">polars_arrow::prelude::QuantileInterpolOptions</span>;

 <span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">DataFrame</span><span class="op">&gt;</span> {
     <span class="kw">let</span> <span class="ident">df</span> <span class="op">=</span> <span class="macro">df!</span>(
     <span class="string">&quot;date&quot;</span> =&gt; [<span class="string">&quot;2020-08-21&quot;</span>, <span class="string">&quot;2020-08-21&quot;</span>, <span class="string">&quot;2020-08-22&quot;</span>, <span class="string">&quot;2020-08-23&quot;</span>, <span class="string">&quot;2020-08-22&quot;</span>],
     <span class="string">&quot;temp&quot;</span> =&gt; [<span class="number">20</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>],
     <span class="string">&quot;rain&quot;</span> =&gt; [<span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.01</span>]
     )<span class="question-mark">?</span>;

     <span class="ident">df</span>.<span class="ident">lazy</span>()
     .<span class="ident">groupby</span>([<span class="ident">col</span>(<span class="string">&quot;date&quot;</span>)])
     .<span class="ident">agg</span>([
         <span class="ident">col</span>(<span class="string">&quot;rain&quot;</span>).<span class="ident">min</span>(),
         <span class="ident">col</span>(<span class="string">&quot;rain&quot;</span>).<span class="ident">sum</span>(),
         <span class="ident">col</span>(<span class="string">&quot;rain&quot;</span>).<span class="ident">quantile</span>(<span class="number">0.5</span>, <span class="ident">QuantileInterpolOptions::Nearest</span>).<span class="ident">alias</span>(<span class="string">&quot;median_rain&quot;</span>),
     ])
     .<span class="ident">sort</span>(<span class="string">&quot;date&quot;</span>, <span class="bool-val">false</span>)
     .<span class="ident">collect</span>()

 }</code></pre></div>
<h5 id="calling-any-function" class="section-header"><a href="#calling-any-function">Calling any function</a></h5>
<p>Below we lazily call a custom closure of type <code>Series =&gt; Result&lt;Series&gt;</code>. Because the closure
changes the type/variant of the Series we also define the return type. This is important because
due to the laziness the types should be known beforehand. Note that by applying these custom
functions you have access the the whole <strong>eager API</strong> of the Series/ChunkedArrays.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">polars_core</span>;
 <span class="kw">use</span> <span class="ident">polars_core::prelude</span>::<span class="kw-2">*</span>;
 <span class="kw">use</span> <span class="ident">polars_lazy::prelude</span>::<span class="kw-2">*</span>;

 <span class="kw">let</span> <span class="ident">df</span> <span class="op">=</span> <span class="macro">df!</span> {
     <span class="string">&quot;column_a&quot;</span> =&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">&quot;column_b&quot;</span> =&gt; <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]
 }.<span class="ident">unwrap</span>();

 <span class="kw">let</span> <span class="ident">new</span> <span class="op">=</span> <span class="ident">df</span>.<span class="ident">lazy</span>()
     .<span class="ident">with_column</span>(
         <span class="ident">col</span>(<span class="string">&quot;column_a&quot;</span>)
         <span class="comment">// apply a custom closure Series =&gt; Result&lt;Series&gt;</span>
         .<span class="ident">map</span>(<span class="op">|</span><span class="ident">_s</span><span class="op">|</span> {
             <span class="prelude-val">Ok</span>(<span class="ident">Series::new</span>(<span class="string">&quot;&quot;</span>, <span class="kw-2">&amp;</span>[<span class="number">6.0f32</span>, <span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>]))
         },
         <span class="comment">// return type of the closure</span>
         <span class="ident">GetOutput::from_type</span>(<span class="ident">DataType::Float64</span>)).<span class="ident">alias</span>(<span class="string">&quot;new_column&quot;</span>)
     )
     .<span class="ident">collect</span>()
     .<span class="ident">unwrap</span>();</code></pre></div>
<h5 id="joins-filters-and-projections" class="section-header"><a href="#joins-filters-and-projections">Joins, filters and projections</a></h5>
<p>In the query below we do a lazy join and afterwards we filter rows based on the predicate <code>a &lt; 2</code>.
And last we select the columns <code>&quot;b&quot;</code> and <code>&quot;c_first&quot;</code>. In an eager API this query would be very
suboptimal because we join on DataFrames with more columns and rows than needed. In this case
the query optimizer will do the selection of the columns (projection) and the filtering of the
rows (selection) before the join, thereby reducing the amount of work done by the query.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn</span> <span class="ident">example</span>(<span class="ident">df_a</span>: <span class="ident">DataFrame</span>, <span class="ident">df_b</span>: <span class="ident">DataFrame</span>) -&gt; <span class="ident">LazyFrame</span> {
    <span class="ident">df_a</span>.<span class="ident">lazy</span>()
    .<span class="ident">left_join</span>(<span class="ident">df_b</span>.<span class="ident">lazy</span>(), <span class="ident">col</span>(<span class="string">&quot;b_left&quot;</span>), <span class="ident">col</span>(<span class="string">&quot;b_right&quot;</span>))
    .<span class="ident">filter</span>(
        <span class="ident">col</span>(<span class="string">&quot;a&quot;</span>).<span class="ident">lt</span>(<span class="ident">lit</span>(<span class="number">2</span>))
    )
    .<span class="ident">groupby</span>([<span class="ident">col</span>(<span class="string">&quot;b&quot;</span>)])
    .<span class="ident">agg</span>(
        <span class="macro">vec!</span>[<span class="ident">col</span>(<span class="string">&quot;b&quot;</span>).<span class="ident">first</span>(), <span class="ident">col</span>(<span class="string">&quot;c&quot;</span>).<span class="ident">first</span>()]
     )
    .<span class="ident">select</span>(<span class="kw-2">&amp;</span>[<span class="ident">col</span>(<span class="string">&quot;b&quot;</span>), <span class="ident">col</span>(<span class="string">&quot;c_first&quot;</span>)])
}</code></pre></div>
<p>If we want to do an aggregation on all columns we can use the wildcard operator <code>*</code> to achieve this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn</span> <span class="ident">aggregate_all_columns</span>(<span class="ident">df_a</span>: <span class="ident">DataFrame</span>) -&gt; <span class="ident">LazyFrame</span> {
    <span class="ident">df_a</span>.<span class="ident">lazy</span>()
    .<span class="ident">groupby</span>([<span class="ident">col</span>(<span class="string">&quot;b&quot;</span>)])
    .<span class="ident">agg</span>(
        <span class="macro">vec!</span>[<span class="ident">col</span>(<span class="string">&quot;*&quot;</span>).<span class="ident">first</span>()]
     )
}</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="dsl/index.html" title="polars_lazy::dsl mod">dsl</a></div><div class="item-right docblock-short"><p>Domain specific language for the Lazy api.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="frame/index.html" title="polars_lazy::frame mod">frame</a></div><div class="item-right docblock-short"><p>Lazy variant of a <a href="../polars_core/frame/struct.DataFrame.html">DataFrame</a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="functions/index.html" title="polars_lazy::functions mod">functions</a></div><div class="item-right docblock-short"><p>Functions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="logical_plan/index.html" title="polars_lazy::logical_plan mod">logical_plan</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="physical_plan/index.html" title="polars_lazy::physical_plan mod">physical_plan</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="prelude/index.html" title="polars_lazy::prelude mod">prelude</a></div><div class="item-right docblock-short"></div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="polars_lazy" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0-nightly (cfa3fe5af 2021-12-31)" ></div>
</body></html>