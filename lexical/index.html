<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Fast lexical conversion routines."><meta name="keywords" content="rust, rustlang, rust-lang, lexical"><title>lexical - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../lexical/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.png" alt="logo"></div>
        </a><h2 class="location">Crate lexical</h2><div class="block version"><div class="narrow-helper"></div><p>Version 6.0.1</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all lexical's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="lexical" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../lexical/index.html"><img class="rust-logo" src="../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">lexical</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/lexical/lib.rs.html#1-556" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Fast lexical conversion routines.</p>
<p>Fast lexical conversion routines for both std and no_std environments.
lexical provides routines to convert numbers to and from decimal
strings. lexical also supports non-base 10 numbers, with the <code>radix</code>
feature, for both integers and floats. lexical is customizable
and yet simple to use: despite supporting nearly every float and
integer format available, it only exports 2 write functions
and 4 parse functions.</p>
<p>lexical is well-tested, and has been downloaded more than 5 million
times and currently has no known errors in correctness. lexical
prioritizes performance above all else, and aims to be competitive
or faster than any other float or integer parser and writer.</p>
<h2 id="getting-started" class="section-header"><a href="#getting-started">Getting Started</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Number to string</span>
<span class="ident">lexical::to_string</span>(<span class="number">3.0</span>);            <span class="comment">// &quot;3.0&quot;, always has a fraction suffix.</span>
<span class="ident">lexical::to_string</span>(<span class="number">3</span>);              <span class="comment">// &quot;3&quot;</span>

<span class="comment">// String to number.</span>
<span class="kw">let</span> <span class="ident">i</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="ident">lexical::parse</span>(<span class="string">&quot;3&quot;</span>).<span class="ident">unwrap</span>();      <span class="comment">// 3, auto-type deduction.</span>
<span class="kw">let</span> <span class="ident">f</span>: <span class="ident">f32</span> <span class="op">=</span> <span class="ident">lexical::parse</span>(<span class="string">&quot;3.5&quot;</span>).<span class="ident">unwrap</span>();    <span class="comment">// 3.5</span>
<span class="kw">let</span> <span class="ident">d</span> <span class="op">=</span> <span class="ident">lexical::parse</span>::<span class="op">&lt;</span><span class="ident">f64</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="string">&quot;3.5&quot;</span>);        <span class="comment">// Ok(3.5), successful parse.</span>
<span class="kw">let</span> <span class="ident">d</span> <span class="op">=</span> <span class="ident">lexical::parse</span>::<span class="op">&lt;</span><span class="ident">f64</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="string">&quot;3a&quot;</span>);         <span class="comment">// Err(Error(_)), failed to parse.</span></code></pre></div>
<h2 id="conversion-api" class="section-header"><a href="#conversion-api">Conversion API</a></h2>
<ul>
<li><a href="fn.parse.html"><code>parse</code></a></li>
<li><a href="fn.parse_partial.html"><code>parse_partial</code></a></li>
<li><a href="fn.parse_with_options.html"><code>parse_with_options</code></a></li>
<li><a href="fn.parse_partial_with_options.html"><code>parse_partial_with_options</code></a></li>
</ul>
<h2 id="features" class="section-header"><a href="#features">Features</a></h2>
<p>In accordance with the Rust ethos, all features are additive: the crate
may be build with <code>--all-features</code> without issue.  The following features are enabled
by default:</p>
<ul>
<li><code>std</code></li>
<li><code>write-integers</code></li>
<li><code>write-floats</code></li>
<li><code>parse-integers</code></li>
<li><code>parse-floats</code></li>
</ul>
<p>A complete description of supported features includes:</p>
<h4 id="std" class="section-header"><a href="#std">std</a></h4>
<p>Enable use of the standard library. Currently, the standard library
is not used for any functionality, and may be disabled without any
change in functionality on stable.</p>
<h4 id="write-integers" class="section-header"><a href="#write-integers">write-integers</a></h4>
<p>Enable support for writing integers to string.</p>
<h4 id="write-floats" class="section-header"><a href="#write-floats">write-floats</a></h4>
<p>Enable support for writing floating-point numbers to string.</p>
<h4 id="parse-integers" class="section-header"><a href="#parse-integers">parse-integers</a></h4>
<p>Enable support for parsing integers from string.</p>
<h4 id="parsing-floats" class="section-header"><a href="#parsing-floats">parsing-floats</a></h4>
<p>Enable support for parsing floating-point numbers from string.</p>
<h4 id="format" class="section-header"><a href="#format">format</a></h4>
<p>Adds support for the entire format API (using <a href="struct.NumberFormatBuilder.html"><code>NumberFormatBuilder</code></a>).
This allows extensive configurability for parsing and writing numbers
in custom formats, with different valid syntax requirements.</p>
<p>For example, in JSON, the following floats are valid or invalid:</p>
<div class="example-wrap"><pre class="language-text"><code>-1          // valid
+1          // invalid
1           // valid
1.          // invalid
.1          // invalid
0.1         // valid
nan         // invalid
inf         // invalid
Infinity    // invalid</code></pre></div>
<p>All of the finite numbers are valid in Rust, and Rust provides constants
for non-finite floats. In order to parse standard-conforming JSON floats
using lexical, you may use the following approach:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">lexical_core</span>::{<span class="ident">format</span>, <span class="ident">parse_with_options</span>, <span class="ident">ParseFloatOptions</span>, <span class="prelude-ty">Result</span>};

<span class="kw">fn</span> <span class="ident">parse_json_float</span><span class="op">&lt;</span><span class="ident">Bytes</span>: <span class="ident">AsRef</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">bytes</span>: <span class="ident">Bytes</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">options</span> <span class="op">=</span> <span class="ident">ParseFloatOptions::new</span>();
    <span class="ident">parse_with_options</span>::<span class="op">&lt;</span><span class="kw">_</span>, { <span class="ident">format::JSON</span> }<span class="op">&gt;</span>(<span class="ident">bytes</span>.<span class="ident">as_ref</span>(), <span class="kw-2">&amp;</span><span class="ident">options</span>)
}</code></pre></div>
<p>See the <a href="#number-format">Number Format</a> section below for more information.</p>
<h4 id="power-of-two" class="section-header"><a href="#power-of-two">power-of-two</a></h4>
<p>Enable doing numeric conversions to and from strings with power-of-two
radixes. This avoids most of the overhead and binary bloat of the radix
feature, while enabling support for the most commonly-used radixes.</p>
<h4 id="radix" class="section-header"><a href="#radix">radix</a></h4>
<p>Enable doing numeric conversions to and from strings for all radixes.
This requires substantially more static storage than <code>power-of-two</code>,
and increases compile times by a fair amount, but can be quite useful
for esoteric programming languages which use duodecimal floats, for
example.</p>
<h4 id="compact" class="section-header"><a href="#compact">compact</a></h4>
<p>Reduce the generated code size at the cost of performance. This minimizes
the number of static tables, inlining, and generics used, drastically
reducing the size of the generated binaries.</p>
<h4 id="safe" class="section-header"><a href="#safe">safe</a></h4>
<p>All numeric parsers are memory-safe by default, since parsing complex
input is a major source of memory vulnerabilities. However, numeric
writers often opt-in for unchecked writes, for major performance
improvements. This may be disabled entirely by enabling the <code>safe</code>
feature. In addition, to simplify memory safety guarantees, extensive
edge-cases, property-based tests, and fuzzing is done with both the
safe feature enabled and disabled, with the tests verified by Miri
and Valgrind.</p>
<h2 id="configuration-api" class="section-header"><a href="#configuration-api">Configuration API</a></h2>
<p>Lexical provides two main levels of configuration:</p>
<ul>
<li>The <a href="struct.NumberFormatBuilder.html"><code>NumberFormatBuilder</code></a>, creating a packed struct with custom
formatting options.</li>
<li>The Options API.</li>
</ul>
<h3 id="number-format" class="section-header"><a href="#number-format">Number Format</a></h3>
<p>The number format class provides numerous flags to specify
number parsing or writing. When the <code>power-of-two</code> feature is
enabled, additional flags are added:</p>
<ul>
<li>The radix for the significant digits (default <code>10</code>).</li>
<li>The radix for the exponent base (default <code>10</code>).</li>
<li>The radix for the exponent digits (default <code>10</code>).</li>
</ul>
<p>When the <code>format</code> feature is enabled, numerous other syntax and
digit separator flags are enabled, including:</p>
<ul>
<li>A digit separator character, to group digits for increased legibility.</li>
<li>Whether leading, trailing, internal, and consecutive digit separators are allowed.</li>
<li>Toggling required float components, such as digits before the decimal point.</li>
<li>Toggling whether special floats are allowed or are case-sensitive.</li>
</ul>
<p>Many pre-defined constants therefore exist to simplify common use-cases,
including:</p>
<ul>
<li>JSON, XML, TOML, YAML, SQLite, and many more.</li>
<li>Rust, Python, C#, FORTRAN, COBOL literals and strings, and many more.</li>
</ul>
<h3 id="options-api" class="section-header"><a href="#options-api">Options API</a></h3>
<p>The Options API provides high-level options to specify number parsing
or writing, options not intrinsically tied to a number format.
For example, the Options API provides:</p>
<ul>
<li>The exponent character (default <code>b'e'</code>, or <code>b'^'</code>).</li>
<li>The decimal point character (default <code>b'.'</code>).</li>
<li>Custom <code>NaN</code>, <code>Infinity</code> string representations.</li>
<li>Whether to trim the fraction component from integral floats.</li>
<li>The exponent break point for scientific notation.</li>
<li>The maximum and minimum number of significant digits to write.</li>
<li>The rounding mode when truncating significant digits while writing.</li>
</ul>
<p>The available options are:</p>
<ul>
<li><a href="struct.ParseFloatOptions.html"><code>ParseFloatOptions</code></a></li>
<li><a href="struct.ParseIntegerOptions.html"><code>ParseIntegerOptions</code></a></li>
</ul>
<p>In addition, pre-defined constants for each category of options may
be found in their respective modules.</p>
<h3 id="example" class="section-header"><a href="#example">Example</a></h3>
<p>An example of creating your own options to parse European-style
numbers (which use commas as decimal points, and periods as digit
separators) is as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This creates a format to parse a European-style float number.</span>
<span class="comment">// The decimal point is a comma, and the digit separators (optional)</span>
<span class="comment">// are periods.</span>
<span class="kw">const</span> <span class="ident">EUROPEAN</span>: <span class="ident">u128</span> <span class="op">=</span> <span class="ident">lexical::NumberFormatBuilder::new</span>()
    .<span class="ident">digit_separator</span>(<span class="string">b&#39;.&#39;</span>)
    .<span class="ident">build</span>()
    .<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">options</span> <span class="op">=</span> <span class="ident">lexical_core::ParseFloatOptions::builder</span>()
    .<span class="ident">decimal_point</span>(<span class="string">b&#39;,&#39;</span>)
    .<span class="ident">build</span>()
    .<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(
    <span class="ident">lexical::parse_with_options</span>::<span class="op">&lt;</span><span class="ident">f32</span>, <span class="ident">EUROPEAN</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="string">&quot;300,10&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">options</span>),
    <span class="prelude-val">Ok</span>(<span class="number">300.10</span>)
);

<span class="comment">// Another example, using a pre-defined constant for JSON.</span>
<span class="kw">const</span> <span class="ident">JSON</span>: <span class="ident">u128</span> <span class="op">=</span> <span class="ident">lexical::format::JSON</span>;
<span class="kw">let</span> <span class="ident">options</span> <span class="op">=</span> <span class="ident">lexical::ParseFloatOptions::new</span>();
<span class="macro">assert_eq!</span>(
    <span class="ident">lexical::parse_with_options</span>::<span class="op">&lt;</span><span class="ident">f32</span>, <span class="ident">JSON</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="string">&quot;0e1&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">options</span>),
    <span class="prelude-val">Ok</span>(<span class="number">0.0</span>)
);
<span class="macro">assert_eq!</span>(
    <span class="ident">lexical::parse_with_options</span>::<span class="op">&lt;</span><span class="ident">f32</span>, <span class="ident">JSON</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="string">&quot;1E+2&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">options</span>),
    <span class="prelude-val">Ok</span>(<span class="number">100.0</span>)
);</code></pre></div>
<h2 id="version-support" class="section-header"><a href="#version-support">Version Support</a></h2>
<p>The minimum, standard, required version is 1.51.0, for const generic
support. Older versions of lexical support older Rust versions.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="format/index.html" title="lexical::format mod">format</a></div><div class="item-right docblock-short"><p>Public API for the number format packed struct.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="parse_float_options/index.html" title="lexical::parse_float_options mod">parse_float_options</a></div><div class="item-right docblock-short"><p>Configuration options for parsing floats.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="parse_integer_options/index.html" title="lexical::parse_integer_options mod">parse_integer_options</a></div><div class="item-right docblock-short"><p>Configuration options for parsing integers.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NumberFormatBuilder.html" title="lexical::NumberFormatBuilder struct">NumberFormatBuilder</a></div><div class="item-right docblock-short"><p>Build number format from specifications.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ParseFloatOptions.html" title="lexical::ParseFloatOptions struct">ParseFloatOptions</a></div><div class="item-right docblock-short"><p>Options to customize parsing floats.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ParseFloatOptionsBuilder.html" title="lexical::ParseFloatOptionsBuilder struct">ParseFloatOptionsBuilder</a></div><div class="item-right docblock-short"><p>Builder for <code>Options</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ParseIntegerOptions.html" title="lexical::ParseIntegerOptions struct">ParseIntegerOptions</a></div><div class="item-right docblock-short"><p>Immutable options to customize writing integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ParseIntegerOptionsBuilder.html" title="lexical::ParseIntegerOptionsBuilder struct">ParseIntegerOptionsBuilder</a></div><div class="item-right docblock-short"><p>Builder for <code>Options</code>.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="lexical::Error enum">Error</a></div><div class="item-right docblock-short"><p>Error code during parsing, indicating failure type.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FromLexical.html" title="lexical::FromLexical trait">FromLexical</a></div><div class="item-right docblock-short"><p>Trait for numerical types that can be parsed from bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FromLexicalWithOptions.html" title="lexical::FromLexicalWithOptions trait">FromLexicalWithOptions</a></div><div class="item-right docblock-short"><p>Trait for numerical types that can be parsed from bytes with custom options.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ParseOptions.html" title="lexical::ParseOptions trait">ParseOptions</a></div><div class="item-right docblock-short"><p>Shared trait for all parser options.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse.html" title="lexical::parse fn">parse</a></div><div class="item-right docblock-short"><p>High-level conversion of decimal-encoded bytes to a number.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_partial.html" title="lexical::parse_partial fn">parse_partial</a></div><div class="item-right docblock-short"><p>High-level, partial conversion of decimal-encoded bytes to a number.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_partial_with_options.html" title="lexical::parse_partial_with_options fn">parse_partial_with_options</a></div><div class="item-right docblock-short"><p>High-level, partial conversion of bytes to a number with custom parsing options.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_with_options.html" title="lexical::parse_with_options fn">parse_with_options</a></div><div class="item-right docblock-short"><p>High-level conversion of bytes to a number with custom parsing options.</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Result.html" title="lexical::Result type">Result</a></div><div class="item-right docblock-short"><p>A specialized Result type for lexical operations.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="lexical" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0-nightly (cfa3fe5af 2021-12-31)" ></div>
</body></html>